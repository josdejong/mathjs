<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | rocket trajectory optimization</title>

  <script src="../../lib/browser/math.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>

  <style>
    body {
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <h1>Rocket trajectory optimization</h1>
  <p>
    This example simulates the ascent stage of the Apollo Lunar Module modeled using a system of ordinary differential equations.
  </p>

  <canvas id=canvas1 width=1600 height=400></canvas>

  <script>
    // Solve ODE `dx/dt = f(x,t), x(0) = x0` numerically. 
    function ndsolve(f, x0, dt, tmax) {
      let x = x0.clone()  // Current values of variables
      const result = []   // Contains entire solution
      const nsteps = math.divide(tmax, dt)   // Number of time steps
      for (let i = 0; i < nsteps; i++) {
        // Compute derivatives
        const dxdt = f.map(func => func(...x.toArray()))
        // Euler method to compute next time step
        const dx = math.multiply(dxdt, dt)
        x = math.add(x, dx)
        result.push(x)
      }
      return math.matrix(result)
    }

    // Import the numerical ODE solver
    math.import({ ndsolve })

    // Create a math.js context for our simulation. Everything else occurs in the context of the expression parser!

    const sim = math.parser()

    // See https://en.wikipedia.org/wiki/Apollo_Lunar_Module
    sim.evaluate("G = 6.67408e-11 m^3 kg^-1 s^-2")  // Gravitational constant
    sim.evaluate("mbody = 7.342e22 kg")             // Mass of Moon
    sim.evaluate("mu = G * mbody")                  // Standard gravitational parameter
    sim.evaluate("dt = 0.1 s")                      // Simulation timestep
    sim.evaluate("tfinal = 410.6 s")                // Simulation duration
    sim.evaluate("T = 16000 N")                     // Engine thrust
    sim.evaluate("g0 = 9.80665 m/s^2")              // Standard gravity: used for calculating prop consumption (dmdt)
    sim.evaluate("isp = 311 s")                     // Specific impulse
    sim.evaluate("gamma0 = 89.34 deg")              // Initial pitch angle (90 deg is vertical)
    sim.evaluate("r0 = 1737.4 km")                  // Mean radius of Moon
    sim.evaluate("v0 = 1 m/s")                      // Initial velocity (must be non-zero because ODE is ill-conditioned)
    sim.evaluate("phi0 = 0 deg")                    // Initial orbital reference angle
    sim.evaluate("m0 = 4700 kg")                    // Initial mass of rocket, gross
    sim.evaluate("mf = 2353 kg")                    // Initial moss of fuel

    // Define the equations of motion. We just thrust into current direction of motion, e.g. making a gravity turn.
    const args = `r, v, m, phi, gamma`
    sim.evaluate(` gravity(${args}) = mu / r^2`)                                // Gravity
    sim.evaluate(`  angVel(${args}) = v/r * cos(gamma) * rad`)                  // Angular velocity of rocket around moon
    sim.evaluate(`    drdt(${args}) = v sin(gamma)`)                            // Vertical velocity
    sim.evaluate(`    dvdt(${args}) = - gravity(${args}) * sin(gamma) + T / m`) // Gravity parallel to movement + Thrust
    sim.evaluate(`    dmdt(${args}) = -T/g0/isp`)
    sim.evaluate(`  dphidt(${args}) = angVel(${args})`)
    sim.evaluate(`dgammadt(${args}) = angVel(${args}) - gravity(${args}) * cos(gamma) / v * rad`) // Angular velocity + Gravity normal to movement

    // Remember to maintain the same variable order in the call to ndsolve.
    sim.evaluate("result_ascent = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt], [r0, v0, m0, phi0, gamma0], dt, tfinal)")

    console.log("fuel left", sim.evaluate("result_ascent[end,3] - (m0 - mf)").toString())
    console.log("orbital minus final velocity", sim.evaluate("sqrt(mu/(result_ascent[end,1])) - result_ascent[end,2]").toString())
    console.log("final state", sim.evaluate("result_ascent[end,:]").toString())

    // Reset initial conditions for unpowered flight
    sim.evaluate("T = 0 N")
    sim.evaluate("tfinal = 60 s")
    sim.evaluate("x = flatten(result_ascent[end,:])")
    sim.evaluate("result_unpowered = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt], x, dt, tfinal)")

    // Extract the useful information from the results so it can be plotted
    const data_ascent = preparePlotData('result_ascent')
    const data_unpowered = preparePlotData('result_unpowered')

    function preparePlotData(resultMatrix) {
      return sim.evaluate(`concat( 
        (${resultMatrix}[:,4] - phi0) * r0 / rad / km,
        (${resultMatrix}[:,1] - r0) / km
      )`).toArray().map(([x, y]) => ({ x, y }))
    }

    const chart = new Chart(document.getElementById('canvas1'), {
      type: 'line',
      data: {
        datasets: [{
          label: "Ascent Stage",
          data: data_ascent,
          fill: false,
          borderColor: "red",
          pointRadius: 0
        }, {
          label: "Unpowered",
          data: data_unpowered,
          fill: false,
          borderColor: "blue",
          pointRadius: 0
        }]
      },
      options: {
        scales: {
          xAxes: [{
            type: 'linear',
            position: 'bottom',
            scaleLabel: {
              display: true,
              labelString: 'surface distance travelled (in km)'
            }
          }],
          yAxes: [{
            type: 'linear',
            scaleLabel: {
              display: true,
              labelString: 'height above surface (in km)'
            }
          }]
        },
        animation: false
      }
    })
  </script>
</body>
</html>
