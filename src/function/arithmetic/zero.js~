import { factory } from '../../utils/factory.js'

const name = 'zero'
const dependencies = [
  'typed', '?BigNumber', '?Complex', '?Fraction', '?unit', 'size', 'zeros'
]

export const createZeroNumber = /* #__PURE__ */ factory(
  name, ['typed'], ({ typed }) => {
    return typed(name, { number: () => 0 })
  })

export const createZero = /* #__PURE__ */ factory(name, dependencies, ({
  typed, BigNumber, Complex, Fraction, unit, size, zeros
}) => {
  /**
   * Return the additive identity of the same type as the argument.
   *
   * Syntax:
   *
   *    math.zero(x)
   *
   * Examples:
   *
   *    math.zero(1.618)                   // returns 0
   *    math.zero(math.bignumber(222))     // BigNumber 0
   *    math.zero(math.fraction(1, 3))     // Fraction 0
   *    math.zero(math.evaluate('0 + 2i')) // Complex 0+0i
   *    math.zero([[2, 3, 4], [4, 5, 6]])  // [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *    typeOf, numeric, one
   *
   * @param {MathType} x  Any entity mathjs understands
   * @return {MathType}  Additive identity of same type as x
   */
  return typed(name, {
    number: () => 0,
    bigint: () => 0n,
    BigNumber: () => new BigNumber(0),
    Complex: () => new Complex(0),
    Fraction: () => new Fraction(0),
    boolean: () => false,
    Unit: typed.referToSelf(self => u => {
      if (u.value === undefined || u.value === null) return unit(0)
      return unit(self(u.value))
    })
    Array: A => zeros(size(A)).valueOf(),
    Matrix: M => zeros(size(M))
  })
})
