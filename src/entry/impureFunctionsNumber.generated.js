/**
 * THIS FILE IS AUTO-GENERATED
 * DON'T MAKE CHANGES HERE
 */
import { config } from './configReadonly'
import {
  createNode,
  createArrayNode,
  createBlockNode,
  createConstantNode,
  createObjectNode,
  createParenthesisNode,
  createRelationalNode,
  createChainClass,
  createChain,
  createReviver,
  createConditionalNode,
  createIndexNode,
  createRangeNode,
  createAccessorNode,
  createFunctionAssignmentNode,
  createSymbolNode,
  createAssignmentNode,
  createFunctionNode,
  createOperatorNode,
  createParse,
  createEvaluate,
  createHelpClass,
  createSimplify,
  createRationalize,
  createCompile,
  createHelp,
  createDerivative,
  createParserClass,
  createParser,
  createFilterTransform,
  createMapTransform,
  createMinTransform,
  createForEachTransform,
  createSubsetTransform,
  createApplyTransform,
  createRangeTransform,
  createMeanTransform,
  createSumTransform,
  createStdTransform,
  createMaxTransform,
  createVarianceTransform
} from '../factoriesNumber'
import {
  ResultSet,
  typed,
  isNumeric,
  typeOf,
  number,
  boolean,
  filter,
  map,
  erf,
  format,
  isPrime,
  round,
  compareText,
  smaller,
  larger,
  max,
  e,
  _false,
  LN10,
  LOG10E,
  _NaN,
  phi,
  SQRT1_2, // eslint-disable-line camelcase
  tau,
  version,
  pickRandom,
  randomInt,
  isNegative,
  isZero,
  matrix,
  unaryPlus,
  addScalar,
  ceil,
  exp,
  fix,
  gcd,
  log10,
  mod,
  multiply,
  sqrt,
  subtract,
  bitAnd,
  bitOr,
  not,
  xor,
  divideScalar,
  log,
  leftShift,
  rightLogShift,
  acos,
  acot,
  acsc,
  asec,
  asin,
  atan,
  atanh,
  cosh,
  coth,
  csch,
  sech,
  sinh,
  tanh,
  norm,
  combinations,
  Range,
  hasNumericValue,
  string,
  forEach,
  prod,
  numeric,
  equalText,
  largerEq,
  min,
  _Infinity,
  LOG2E,
  pi,
  SQRT2,
  random,
  isInteger,
  isNaN,
  abs,
  cube,
  floor,
  log2,
  sign,
  xgcd,
  bitXor,
  subset,
  log1p,
  and,
  acoth,
  asech,
  atan2,
  cot,
  sec,
  tan,
  divide,
  clone,
  nthRoot,
  mode,
  compare,
  smallerEq,
  partitionSelect,
  LN2,
  isPositive,
  cbrt,
  lcm,
  square,
  or,
  rightArithShift,
  acsch,
  cos,
  sin,
  gamma,
  equalScalar,
  range,
  compareNatural,
  unequal,
  _null,
  factorial,
  permutations,
  composition,
  unaryMinus,
  multiplyScalar,
  pow,
  asinh,
  add,
  apply,
  equal,
  hypot,
  mean,
  variance,
  std,
  stirlingS2,
  catalan,
  expm1,
  acosh,
  print,
  _true,
  median,
  quantileSeq,
  bellNumbers,
  csc,
  deepEqual,
  mad,
  bitNot,
  sum,
  multinomial
} from './pureFunctionsNumber.generated'

const math = {} // NOT pure!
const mathWithTransform = {} // NOT pure!
const classes = {} // NOT pure!

export const Node = createNode({ mathWithTransform })
export const ArrayNode = createArrayNode({ Node })
export const BlockNode = createBlockNode({ Node, ResultSet })
export const ConstantNode = createConstantNode({ Node })
export const ObjectNode = createObjectNode({ Node })
export const ParenthesisNode = createParenthesisNode({ Node })
export const RelationalNode = createRelationalNode({ Node })
export const Chain = createChainClass({ math })
export const chain = createChain({ Chain, typed })
export const reviver = createReviver({ classes })
export const ConditionalNode = createConditionalNode({ Node })
export const IndexNode = createIndexNode({ Node, Range })
export const RangeNode = createRangeNode({ Node })
export const AccessorNode = createAccessorNode({ Node, subset })
export const FunctionAssignmentNode = createFunctionAssignmentNode({ Node, typed })
export const SymbolNode = createSymbolNode({ Node, math })
export const AssignmentNode = createAssignmentNode({ matrix, Node, subset })
export const FunctionNode = createFunctionNode({ Node, SymbolNode, math })
export const OperatorNode = createOperatorNode({ Node })
export const parse = createParse({ AccessorNode, ArrayNode, AssignmentNode, BlockNode, ConditionalNode, ConstantNode, FunctionAssignmentNode, FunctionNode, IndexNode, ObjectNode, OperatorNode, ParenthesisNode, RangeNode, RelationalNode, SymbolNode, config, numeric, typed })
export const evaluate = createEvaluate({ parse, typed })
export const Help = createHelpClass({ parse })
export const simplify = createSimplify({ ConstantNode, FunctionNode, OperatorNode, ParenthesisNode, SymbolNode, add, config, divide, equal, isZero, math, multiply, parse, pow, subtract, typed })
export const rationalize = createRationalize({ ConstantNode, FunctionNode, OperatorNode, ParenthesisNode, SymbolNode, add, config, divide, equal, isZero, math, multiply, parse, pow, simplify, subtract, typed })
export const compile = createCompile({ parse, typed })
export const help = createHelp({ Help, math, typed })
export const derivative = createDerivative({ ConstantNode, FunctionNode, OperatorNode, ParenthesisNode, SymbolNode, config, equal, isZero, numeric, parse, simplify, typed })
export const Parser = createParserClass({ parse })
export const parser = createParser({ Parser, math, typed })

Object.assign(math, {
  typed,
  isNumeric,
  typeOf,
  number,
  boolean,
  filter,
  map,
  erf,
  format,
  isPrime,
  round,
  compareText,
  smaller,
  larger,
  max,
  e,
  false: _false,
  LN10,
  LOG10E,
  NaN: _NaN,
  phi,
  SQRT1_2,
  tau,
  version,
  pickRandom,
  randomInt,
  chain,
  reviver,
  isNegative,
  isZero,
  matrix,
  unaryPlus,
  addScalar,
  ceil,
  exp,
  fix,
  gcd,
  log10,
  mod,
  multiply,
  sqrt,
  subtract,
  bitAnd,
  bitOr,
  not,
  xor,
  divideScalar,
  log,
  leftShift,
  rightLogShift,
  acos,
  acot,
  acsc,
  asec,
  asin,
  atan,
  atanh,
  cosh,
  coth,
  csch,
  sech,
  sinh,
  tanh,
  norm,
  combinations,
  hasNumericValue,
  string,
  forEach,
  prod,
  numeric,
  equalText,
  largerEq,
  min,
  Infinity: _Infinity,
  LOG2E,
  pi,
  SQRT2,
  random,
  isInteger,
  isNaN,
  abs,
  cube,
  floor,
  log2,
  sign,
  xgcd,
  bitXor,
  subset,
  log1p,
  and,
  acoth,
  asech,
  atan2,
  cot,
  sec,
  tan,
  divide,
  clone,
  nthRoot,
  mode,
  compare,
  smallerEq,
  partitionSelect,
  LN2,
  'PI': pi,
  isPositive,
  cbrt,
  lcm,
  square,
  or,
  rightArithShift,
  acsch,
  cos,
  sin,
  gamma,
  equalScalar,
  range,
  compareNatural,
  unequal,
  null: _null,
  factorial,
  permutations,
  composition,
  unaryMinus,
  multiplyScalar,
  pow,
  asinh,
  add,
  apply,
  equal,
  'E': e,
  hypot,
  mean,
  variance,
  std,
  stirlingS2,
  catalan,
  expm1,
  acosh,
  print,
  true: _true,
  median,
  quantileSeq,
  bellNumbers,
  parse,
  evaluate,
  simplify,
  rationalize,
  csc,
  deepEqual,
  mad,
  compile,
  help,
  bitNot,
  sum,
  derivative,
  multinomial,
  parser,
  config
})

Object.assign(mathWithTransform, math, {
  filter: createFilterTransform({ typed }),
  map: createMapTransform({ typed }),
  min: createMinTransform({ smaller, typed }),
  forEach: createForEachTransform({ typed }),
  subset: createSubsetTransform({ matrix, typed }),
  apply: createApplyTransform({ isInteger, typed }),
  range: createRangeTransform({ matrix, config, larger, largerEq, smaller, smallerEq, typed }),
  mean: createMeanTransform({ add, divide, typed }),
  sum: createSumTransform({ add, config, typed }),
  std: createStdTransform({ sqrt, typed, variance }),
  max: createMaxTransform({ larger, typed }),
  variance: createVarianceTransform({ add, apply, divide, isNaN, multiply, subtract, typed })
})

Object.assign(classes, {
  ResultSet,
  Node,
  ArrayNode,
  BlockNode,
  ConstantNode,
  ObjectNode,
  ParenthesisNode,
  RelationalNode,
  Chain,
  Range,
  ConditionalNode,
  IndexNode,
  RangeNode,
  AccessorNode,
  FunctionAssignmentNode,
  SymbolNode,
  AssignmentNode,
  FunctionNode,
  OperatorNode,
  Help,
  Parser
})

Chain.createProxy(math)

export { embeddedDocs as docs } from '../expression/embeddedDocs/embeddedDocs'
